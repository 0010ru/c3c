// #target: macos-x64
module test;
import std::io;

fault Test { FOO }

fn void test1()
{
	int! a = 1;
	int! b = a = Test.FOO!;
	if (catch err = a) io::printfln("A err was: %s", err);
	if (catch err = b) io::printfln("B err was: %s", err);
	io::printfln("A was: %s", a);
	io::printfln("B was: %s", b);
}

fn void test2()
{
	int! x = Test.FOO!;
	int! a = 1;
	int! b = a = x;
	if (catch err = a) io::printfln("A err was: %s", err);
	if (catch err = b) io::printfln("B err was: %s", err);
	io::printfln("A was: %s", a);
	io::printfln("B was: %s", b);
}


fn void test3()
{
	int! x = 23;
	int! a = 1;
	int! b = a = x;
	if (catch err = a) io::printfln("A err was: %s", err);
	if (catch err = b) io::printfln("B err was: %s", err);
	io::printfln("A was: %s", a);
	io::printfln("B was: %s", b);
}

fn void main()
{
	test1();
	test2();
	test3();
}

/* #expect: test.ll

; Function Attrs: nounwind
define void @test_test1() #0 {
entry:
  %a = alloca i32, align 4
  %a.f = alloca i64, align 8
  %b = alloca i32, align 4
  %b.f = alloca i64, align 8
  %err = alloca i64, align 8
  %retparam = alloca i64, align 8
  %taddr = alloca %"char[]", align 8
  %vararg = alloca %"variant[]", align 8
  %varargslots = alloca [1 x %variant], align 16
  %err5 = alloca i64, align 8
  %retparam13 = alloca i64, align 8
  %taddr14 = alloca %"char[]", align 8
  %vararg17 = alloca %"variant[]", align 8
  %varargslots18 = alloca [1 x %variant], align 16
  %retparam25 = alloca i64, align 8
  %taddr26 = alloca %"char[]", align 8
  %vararg29 = alloca %"variant[]", align 8
  %varargslots30 = alloca [1 x %variant], align 16
  %retparam38 = alloca i64, align 8
  %taddr39 = alloca %"char[]", align 8
  %vararg42 = alloca %"variant[]", align 8
  %varargslots43 = alloca [1 x %variant], align 16
  store i32 1, i32* %a, align 4
  store i64 0, i64* %a.f, align 8
  store i64 ptrtoint (%.fault* @"test_Test$FOO" to i64), i64* %a.f, align 8
  store i64 ptrtoint (%.fault* @"test_Test$FOO" to i64), i64* %b.f, align 8
  br label %after_assign

after_assign:                                     ; preds = %entry
  br label %testblock

testblock:                                        ; preds = %after_assign
  %0 = load i64, i64* %a.f, align 8
  %not_err = icmp eq i64 %0, 0
  br i1 %not_err, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %testblock
  store i64 %0, i64* %err, align 8
  br label %end_block

after_check:                                      ; preds = %testblock
  store i64 0, i64* %err, align 8
  br label %end_block

end_block:                                        ; preds = %after_check, %assign_optional
  %1 = load i64, i64* %err, align 8
  %neq = icmp ne i64 %1, 0
  br i1 %neq, label %if.then, label %if.exit

if.then:                                          ; preds = %end_block
  store %"char[]" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i32 0, i32 0), i64 13 }, %"char[]"* %taddr, align 8
  %2 = bitcast %"char[]"* %taddr to { i8*, i64 }*
  %3 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %2, i32 0, i32 0
  %lo = load i8*, i8** %3, align 8
  %4 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %2, i32 0, i32 1
  %hi = load i64, i64* %4, align 8
  %5 = bitcast i64* %err to i8*
  %6 = insertvalue %variant undef, i8* %5, 0
  %7 = insertvalue %variant %6, i64 ptrtoint (%.introspect* @"ct$anyerr" to i64), 1
  %8 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots, i64 0, i64 0
  store %variant %7, %variant* %8, align 16
  %9 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 1
  store i64 1, i64* %9, align 8
  %10 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 0
  %11 = bitcast [1 x %variant]* %varargslots to %variant*
  store %variant* %11, %variant** %10, align 8
  %12 = bitcast %"variant[]"* %vararg to { i8*, i64 }*
  %13 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %12, i32 0, i32 0
  %lo1 = load i8*, i8** %13, align 8
  %14 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %12, i32 0, i32 1
  %hi2 = load i64, i64* %14, align 8
  %15 = call i64 @std_io_printfln(i64* %retparam, i8* %lo, i64 %hi, i8* %lo1, i64 %hi2)
  %not_err3 = icmp eq i64 %15, 0
  br i1 %not_err3, label %after_check4, label %voiderr

after_check4:                                     ; preds = %if.then
  br label %voiderr

voiderr:                                          ; preds = %after_check4, %if.then
  br label %if.exit

if.exit:                                          ; preds = %voiderr, %end_block
  br label %testblock6

testblock6:                                       ; preds = %if.exit
  %16 = load i64, i64* %b.f, align 8
  %not_err7 = icmp eq i64 %16, 0
  br i1 %not_err7, label %after_check9, label %assign_optional8

assign_optional8:                                 ; preds = %testblock6
  store i64 %16, i64* %err5, align 8
  br label %end_block10

after_check9:                                     ; preds = %testblock6
  store i64 0, i64* %err5, align 8
  br label %end_block10

end_block10:                                      ; preds = %after_check9, %assign_optional8
  %17 = load i64, i64* %err5, align 8
  %neq11 = icmp ne i64 %17, 0
  br i1 %neq11, label %if.then12, label %if.exit24

if.then12:                                        ; preds = %end_block10
  store %"char[]" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.1, i32 0, i32 0), i64 13 }, %"char[]"* %taddr14, align 8
  %18 = bitcast %"char[]"* %taddr14 to { i8*, i64 }*
  %19 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %18, i32 0, i32 0
  %lo15 = load i8*, i8** %19, align 8
  %20 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %18, i32 0, i32 1
  %hi16 = load i64, i64* %20, align 8
  %21 = bitcast i64* %err5 to i8*
  %22 = insertvalue %variant undef, i8* %21, 0
  %23 = insertvalue %variant %22, i64 ptrtoint (%.introspect* @"ct$anyerr" to i64), 1
  %24 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots18, i64 0, i64 0
  store %variant %23, %variant* %24, align 16
  %25 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg17, i32 0, i32 1
  store i64 1, i64* %25, align 8
  %26 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg17, i32 0, i32 0
  %27 = bitcast [1 x %variant]* %varargslots18 to %variant*
  store %variant* %27, %variant** %26, align 8
  %28 = bitcast %"variant[]"* %vararg17 to { i8*, i64 }*
  %29 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %28, i32 0, i32 0
  %lo19 = load i8*, i8** %29, align 8
  %30 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %28, i32 0, i32 1
  %hi20 = load i64, i64* %30, align 8
  %31 = call i64 @std_io_printfln(i64* %retparam13, i8* %lo15, i64 %hi16, i8* %lo19, i64 %hi20)
  %not_err21 = icmp eq i64 %31, 0
  br i1 %not_err21, label %after_check22, label %voiderr23

after_check22:                                    ; preds = %if.then12
  br label %voiderr23

voiderr23:                                        ; preds = %after_check22, %if.then12
  br label %if.exit24

if.exit24:                                        ; preds = %voiderr23, %end_block10
  store %"char[]" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i64 9 }, %"char[]"* %taddr26, align 8
  %32 = bitcast %"char[]"* %taddr26 to { i8*, i64 }*
  %33 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %32, i32 0, i32 0
  %lo27 = load i8*, i8** %33, align 8
  %34 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %32, i32 0, i32 1
  %hi28 = load i64, i64* %34, align 8
  %35 = load i64, i64* %a.f, align 8
  %not_err31 = icmp eq i64 %35, 0
  br i1 %not_err31, label %after_check32, label %voiderr37

after_check32:                                    ; preds = %if.exit24
  %36 = bitcast i32* %a to i8*
  %37 = insertvalue %variant undef, i8* %36, 0
  %38 = insertvalue %variant %37, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %39 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots30, i64 0, i64 0
  store %variant %38, %variant* %39, align 16
  %40 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg29, i32 0, i32 1
  store i64 1, i64* %40, align 8
  %41 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg29, i32 0, i32 0
  %42 = bitcast [1 x %variant]* %varargslots30 to %variant*
  store %variant* %42, %variant** %41, align 8
  %43 = bitcast %"variant[]"* %vararg29 to { i8*, i64 }*
  %44 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %43, i32 0, i32 0
  %lo33 = load i8*, i8** %44, align 8
  %45 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %43, i32 0, i32 1
  %hi34 = load i64, i64* %45, align 8
  %46 = call i64 @std_io_printfln(i64* %retparam25, i8* %lo27, i64 %hi28, i8* %lo33, i64 %hi34)
  %not_err35 = icmp eq i64 %46, 0
  br i1 %not_err35, label %after_check36, label %voiderr37

after_check36:                                    ; preds = %after_check32
  br label %voiderr37

voiderr37:                                        ; preds = %after_check36, %after_check32, %if.exit24
  store %"char[]" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i64 9 }, %"char[]"* %taddr39, align 8
  %47 = bitcast %"char[]"* %taddr39 to { i8*, i64 }*
  %48 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %47, i32 0, i32 0
  %lo40 = load i8*, i8** %48, align 8
  %49 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %47, i32 0, i32 1
  %hi41 = load i64, i64* %49, align 8
  %50 = load i64, i64* %b.f, align 8
  %not_err44 = icmp eq i64 %50, 0
  br i1 %not_err44, label %after_check45, label %voiderr50

after_check45:                                    ; preds = %voiderr37
  %51 = bitcast i32* %b to i8*
  %52 = insertvalue %variant undef, i8* %51, 0
  %53 = insertvalue %variant %52, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %54 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots43, i64 0, i64 0
  store %variant %53, %variant* %54, align 16
  %55 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg42, i32 0, i32 1
  store i64 1, i64* %55, align 8
  %56 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg42, i32 0, i32 0
  %57 = bitcast [1 x %variant]* %varargslots43 to %variant*
  store %variant* %57, %variant** %56, align 8
  %58 = bitcast %"variant[]"* %vararg42 to { i8*, i64 }*
  %59 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %58, i32 0, i32 0
  %lo46 = load i8*, i8** %59, align 8
  %60 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %58, i32 0, i32 1
  %hi47 = load i64, i64* %60, align 8
  %61 = call i64 @std_io_printfln(i64* %retparam38, i8* %lo40, i64 %hi41, i8* %lo46, i64 %hi47)
  %not_err48 = icmp eq i64 %61, 0
  br i1 %not_err48, label %after_check49, label %voiderr50

after_check49:                                    ; preds = %after_check45
  br label %voiderr50

voiderr50:                                        ; preds = %after_check49, %after_check45, %voiderr37
  ret void
}

; Function Attrs: nounwind
define void @test_test2() #0 {
entry:
  %x = alloca i32, align 4
  %x.f = alloca i64, align 8
  %a = alloca i32, align 4
  %a.f = alloca i64, align 8
  %b = alloca i32, align 4
  %b.f = alloca i64, align 8
  %err = alloca i64, align 8
  %retparam = alloca i64, align 8
  %taddr = alloca %"char[]", align 8
  %vararg = alloca %"variant[]", align 8
  %varargslots = alloca [1 x %variant], align 16
  %err9 = alloca i64, align 8
  %retparam17 = alloca i64, align 8
  %taddr18 = alloca %"char[]", align 8
  %vararg21 = alloca %"variant[]", align 8
  %varargslots22 = alloca [1 x %variant], align 16
  %retparam29 = alloca i64, align 8
  %taddr30 = alloca %"char[]", align 8
  %vararg33 = alloca %"variant[]", align 8
  %varargslots34 = alloca [1 x %variant], align 16
  %retparam42 = alloca i64, align 8
  %taddr43 = alloca %"char[]", align 8
  %vararg46 = alloca %"variant[]", align 8
  %varargslots47 = alloca [1 x %variant], align 16
  store i64 ptrtoint (%.fault* @"test_Test$FOO" to i64), i64* %x.f, align 8
  store i32 1, i32* %a, align 4
  store i64 0, i64* %a.f, align 8
  %0 = load i64, i64* %x.f, align 8
  %not_err = icmp eq i64 %0, 0
  br i1 %not_err, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %entry
  store i64 %0, i64* %a.f, align 8
  br label %optional_assign_jump

after_check:                                      ; preds = %entry
  %1 = load i32, i32* %x, align 4
  store i32 %1, i32* %a, align 4
  store i64 0, i64* %a.f, align 8
  br label %after_assign

optional_assign_jump:                             ; preds = %assign_optional
  %reload_err = load i64, i64* %a.f, align 8
  store i64 %reload_err, i64* %b.f, align 8
  br label %after_assign1

after_assign:                                     ; preds = %after_check
  store i32 %1, i32* %b, align 4
  store i64 0, i64* %b.f, align 8
  br label %after_assign1

after_assign1:                                    ; preds = %after_assign, %optional_assign_jump
  br label %testblock

testblock:                                        ; preds = %after_assign1
  %2 = load i64, i64* %a.f, align 8
  %not_err2 = icmp eq i64 %2, 0
  br i1 %not_err2, label %after_check4, label %assign_optional3

assign_optional3:                                 ; preds = %testblock
  store i64 %2, i64* %err, align 8
  br label %end_block

after_check4:                                     ; preds = %testblock
  store i64 0, i64* %err, align 8
  br label %end_block

end_block:                                        ; preds = %after_check4, %assign_optional3
  %3 = load i64, i64* %err, align 8
  %neq = icmp ne i64 %3, 0
  br i1 %neq, label %if.then, label %if.exit

if.then:                                          ; preds = %end_block
  store %"char[]" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.4, i32 0, i32 0), i64 13 }, %"char[]"* %taddr, align 8
  %4 = bitcast %"char[]"* %taddr to { i8*, i64 }*
  %5 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 0
  %lo = load i8*, i8** %5, align 8
  %6 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 1
  %hi = load i64, i64* %6, align 8
  %7 = bitcast i64* %err to i8*
  %8 = insertvalue %variant undef, i8* %7, 0
  %9 = insertvalue %variant %8, i64 ptrtoint (%.introspect* @"ct$anyerr" to i64), 1
  %10 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots, i64 0, i64 0
  store %variant %9, %variant* %10, align 16
  %11 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 1
  store i64 1, i64* %11, align 8
  %12 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 0
  %13 = bitcast [1 x %variant]* %varargslots to %variant*
  store %variant* %13, %variant** %12, align 8
  %14 = bitcast %"variant[]"* %vararg to { i8*, i64 }*
  %15 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %14, i32 0, i32 0
  %lo5 = load i8*, i8** %15, align 8
  %16 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %14, i32 0, i32 1
  %hi6 = load i64, i64* %16, align 8
  %17 = call i64 @std_io_printfln(i64* %retparam, i8* %lo, i64 %hi, i8* %lo5, i64 %hi6)
  %not_err7 = icmp eq i64 %17, 0
  br i1 %not_err7, label %after_check8, label %voiderr

after_check8:                                     ; preds = %if.then
  br label %voiderr

voiderr:                                          ; preds = %after_check8, %if.then
  br label %if.exit

if.exit:                                          ; preds = %voiderr, %end_block
  br label %testblock10

testblock10:                                      ; preds = %if.exit
  %18 = load i64, i64* %b.f, align 8
  %not_err11 = icmp eq i64 %18, 0
  br i1 %not_err11, label %after_check13, label %assign_optional12

assign_optional12:                                ; preds = %testblock10
  store i64 %18, i64* %err9, align 8
  br label %end_block14

after_check13:                                    ; preds = %testblock10
  store i64 0, i64* %err9, align 8
  br label %end_block14

end_block14:                                      ; preds = %after_check13, %assign_optional12
  %19 = load i64, i64* %err9, align 8
  %neq15 = icmp ne i64 %19, 0
  br i1 %neq15, label %if.then16, label %if.exit28

if.then16:                                        ; preds = %end_block14
  store %"char[]" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.5, i32 0, i32 0), i64 13 }, %"char[]"* %taddr18, align 8
  %20 = bitcast %"char[]"* %taddr18 to { i8*, i64 }*
  %21 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %20, i32 0, i32 0
  %lo19 = load i8*, i8** %21, align 8
  %22 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %20, i32 0, i32 1
  %hi20 = load i64, i64* %22, align 8
  %23 = bitcast i64* %err9 to i8*
  %24 = insertvalue %variant undef, i8* %23, 0
  %25 = insertvalue %variant %24, i64 ptrtoint (%.introspect* @"ct$anyerr" to i64), 1
  %26 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots22, i64 0, i64 0
  store %variant %25, %variant* %26, align 16
  %27 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg21, i32 0, i32 1
  store i64 1, i64* %27, align 8
  %28 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg21, i32 0, i32 0
  %29 = bitcast [1 x %variant]* %varargslots22 to %variant*
  store %variant* %29, %variant** %28, align 8
  %30 = bitcast %"variant[]"* %vararg21 to { i8*, i64 }*
  %31 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %30, i32 0, i32 0
  %lo23 = load i8*, i8** %31, align 8
  %32 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %30, i32 0, i32 1
  %hi24 = load i64, i64* %32, align 8
  %33 = call i64 @std_io_printfln(i64* %retparam17, i8* %lo19, i64 %hi20, i8* %lo23, i64 %hi24)
  %not_err25 = icmp eq i64 %33, 0
  br i1 %not_err25, label %after_check26, label %voiderr27

after_check26:                                    ; preds = %if.then16
  br label %voiderr27

voiderr27:                                        ; preds = %after_check26, %if.then16
  br label %if.exit28

if.exit28:                                        ; preds = %voiderr27, %end_block14
  store %"char[]" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6, i32 0, i32 0), i64 9 }, %"char[]"* %taddr30, align 8
  %34 = bitcast %"char[]"* %taddr30 to { i8*, i64 }*
  %35 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %34, i32 0, i32 0
  %lo31 = load i8*, i8** %35, align 8
  %36 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %34, i32 0, i32 1
  %hi32 = load i64, i64* %36, align 8
  %37 = load i64, i64* %a.f, align 8
  %not_err35 = icmp eq i64 %37, 0
  br i1 %not_err35, label %after_check36, label %voiderr41

after_check36:                                    ; preds = %if.exit28
  %38 = bitcast i32* %a to i8*
  %39 = insertvalue %variant undef, i8* %38, 0
  %40 = insertvalue %variant %39, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %41 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots34, i64 0, i64 0
  store %variant %40, %variant* %41, align 16
  %42 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg33, i32 0, i32 1
  store i64 1, i64* %42, align 8
  %43 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg33, i32 0, i32 0
  %44 = bitcast [1 x %variant]* %varargslots34 to %variant*
  store %variant* %44, %variant** %43, align 8
  %45 = bitcast %"variant[]"* %vararg33 to { i8*, i64 }*
  %46 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %45, i32 0, i32 0
  %lo37 = load i8*, i8** %46, align 8
  %47 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %45, i32 0, i32 1
  %hi38 = load i64, i64* %47, align 8
  %48 = call i64 @std_io_printfln(i64* %retparam29, i8* %lo31, i64 %hi32, i8* %lo37, i64 %hi38)
  %not_err39 = icmp eq i64 %48, 0
  br i1 %not_err39, label %after_check40, label %voiderr41

after_check40:                                    ; preds = %after_check36
  br label %voiderr41

voiderr41:                                        ; preds = %after_check40, %after_check36, %if.exit28
  store %"char[]" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7, i32 0, i32 0), i64 9 }, %"char[]"* %taddr43, align 8
  %49 = bitcast %"char[]"* %taddr43 to { i8*, i64 }*
  %50 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %49, i32 0, i32 0
  %lo44 = load i8*, i8** %50, align 8
  %51 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %49, i32 0, i32 1
  %hi45 = load i64, i64* %51, align 8
  %52 = load i64, i64* %b.f, align 8
  %not_err48 = icmp eq i64 %52, 0
  br i1 %not_err48, label %after_check49, label %voiderr54

after_check49:                                    ; preds = %voiderr41
  %53 = bitcast i32* %b to i8*
  %54 = insertvalue %variant undef, i8* %53, 0
  %55 = insertvalue %variant %54, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %56 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots47, i64 0, i64 0
  store %variant %55, %variant* %56, align 16
  %57 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg46, i32 0, i32 1
  store i64 1, i64* %57, align 8
  %58 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg46, i32 0, i32 0
  %59 = bitcast [1 x %variant]* %varargslots47 to %variant*
  store %variant* %59, %variant** %58, align 8
  %60 = bitcast %"variant[]"* %vararg46 to { i8*, i64 }*
  %61 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %60, i32 0, i32 0
  %lo50 = load i8*, i8** %61, align 8
  %62 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %60, i32 0, i32 1
  %hi51 = load i64, i64* %62, align 8
  %63 = call i64 @std_io_printfln(i64* %retparam42, i8* %lo44, i64 %hi45, i8* %lo50, i64 %hi51)
  %not_err52 = icmp eq i64 %63, 0
  br i1 %not_err52, label %after_check53, label %voiderr54

after_check53:                                    ; preds = %after_check49
  br label %voiderr54

voiderr54:                                        ; preds = %after_check53, %after_check49, %voiderr41
  ret void
}

; Function Attrs: nounwind
define void @test_test3() #0 {
entry:
  %x = alloca i32, align 4
  %x.f = alloca i64, align 8
  %a = alloca i32, align 4
  %a.f = alloca i64, align 8
  %b = alloca i32, align 4
  %b.f = alloca i64, align 8
  %err = alloca i64, align 8
  %retparam = alloca i64, align 8
  %taddr = alloca %"char[]", align 8
  %vararg = alloca %"variant[]", align 8
  %varargslots = alloca [1 x %variant], align 16
  %err9 = alloca i64, align 8
  %retparam17 = alloca i64, align 8
  %taddr18 = alloca %"char[]", align 8
  %vararg21 = alloca %"variant[]", align 8
  %varargslots22 = alloca [1 x %variant], align 16
  %retparam29 = alloca i64, align 8
  %taddr30 = alloca %"char[]", align 8
  %vararg33 = alloca %"variant[]", align 8
  %varargslots34 = alloca [1 x %variant], align 16
  %retparam42 = alloca i64, align 8
  %taddr43 = alloca %"char[]", align 8
  %vararg46 = alloca %"variant[]", align 8
  %varargslots47 = alloca [1 x %variant], align 16
  store i32 23, i32* %x, align 4
  store i64 0, i64* %x.f, align 8
  store i32 1, i32* %a, align 4
  store i64 0, i64* %a.f, align 8
  %0 = load i64, i64* %x.f, align 8
  %not_err = icmp eq i64 %0, 0
  br i1 %not_err, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %entry
  store i64 %0, i64* %a.f, align 8
  br label %optional_assign_jump

after_check:                                      ; preds = %entry
  %1 = load i32, i32* %x, align 4
  store i32 %1, i32* %a, align 4
  store i64 0, i64* %a.f, align 8
  br label %after_assign

optional_assign_jump:                             ; preds = %assign_optional
  %reload_err = load i64, i64* %a.f, align 8
  store i64 %reload_err, i64* %b.f, align 8
  br label %after_assign1

after_assign:                                     ; preds = %after_check
  store i32 %1, i32* %b, align 4
  store i64 0, i64* %b.f, align 8
  br label %after_assign1

after_assign1:                                    ; preds = %after_assign, %optional_assign_jump
  br label %testblock

testblock:                                        ; preds = %after_assign1
  %2 = load i64, i64* %a.f, align 8
  %not_err2 = icmp eq i64 %2, 0
  br i1 %not_err2, label %after_check4, label %assign_optional3

assign_optional3:                                 ; preds = %testblock
  store i64 %2, i64* %err, align 8
  br label %end_block

after_check4:                                     ; preds = %testblock
  store i64 0, i64* %err, align 8
  br label %end_block

end_block:                                        ; preds = %after_check4, %assign_optional3
  %3 = load i64, i64* %err, align 8
  %neq = icmp ne i64 %3, 0
  br i1 %neq, label %if.then, label %if.exit

if.then:                                          ; preds = %end_block
  store %"char[]" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.8, i32 0, i32 0), i64 13 }, %"char[]"* %taddr, align 8
  %4 = bitcast %"char[]"* %taddr to { i8*, i64 }*
  %5 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 0
  %lo = load i8*, i8** %5, align 8
  %6 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 1
  %hi = load i64, i64* %6, align 8
  %7 = bitcast i64* %err to i8*
  %8 = insertvalue %variant undef, i8* %7, 0
  %9 = insertvalue %variant %8, i64 ptrtoint (%.introspect* @"ct$anyerr" to i64), 1
  %10 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots, i64 0, i64 0
  store %variant %9, %variant* %10, align 16
  %11 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 1
  store i64 1, i64* %11, align 8
  %12 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 0
  %13 = bitcast [1 x %variant]* %varargslots to %variant*
  store %variant* %13, %variant** %12, align 8
  %14 = bitcast %"variant[]"* %vararg to { i8*, i64 }*
  %15 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %14, i32 0, i32 0
  %lo5 = load i8*, i8** %15, align 8
  %16 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %14, i32 0, i32 1
  %hi6 = load i64, i64* %16, align 8
  %17 = call i64 @std_io_printfln(i64* %retparam, i8* %lo, i64 %hi, i8* %lo5, i64 %hi6)
  %not_err7 = icmp eq i64 %17, 0
  br i1 %not_err7, label %after_check8, label %voiderr

after_check8:                                     ; preds = %if.then
  br label %voiderr

voiderr:                                          ; preds = %after_check8, %if.then
  br label %if.exit

if.exit:                                          ; preds = %voiderr, %end_block
  br label %testblock10

testblock10:                                      ; preds = %if.exit
  %18 = load i64, i64* %b.f, align 8
  %not_err11 = icmp eq i64 %18, 0
  br i1 %not_err11, label %after_check13, label %assign_optional12

assign_optional12:                                ; preds = %testblock10
  store i64 %18, i64* %err9, align 8
  br label %end_block14

after_check13:                                    ; preds = %testblock10
  store i64 0, i64* %err9, align 8
  br label %end_block14

end_block14:                                      ; preds = %after_check13, %assign_optional12
  %19 = load i64, i64* %err9, align 8
  %neq15 = icmp ne i64 %19, 0
  br i1 %neq15, label %if.then16, label %if.exit28

if.then16:                                        ; preds = %end_block14
  store %"char[]" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.9, i32 0, i32 0), i64 13 }, %"char[]"* %taddr18, align 8
  %20 = bitcast %"char[]"* %taddr18 to { i8*, i64 }*
  %21 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %20, i32 0, i32 0
  %lo19 = load i8*, i8** %21, align 8
  %22 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %20, i32 0, i32 1
  %hi20 = load i64, i64* %22, align 8
  %23 = bitcast i64* %err9 to i8*
  %24 = insertvalue %variant undef, i8* %23, 0
  %25 = insertvalue %variant %24, i64 ptrtoint (%.introspect* @"ct$anyerr" to i64), 1
  %26 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots22, i64 0, i64 0
  store %variant %25, %variant* %26, align 16
  %27 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg21, i32 0, i32 1
  store i64 1, i64* %27, align 8
  %28 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg21, i32 0, i32 0
  %29 = bitcast [1 x %variant]* %varargslots22 to %variant*
  store %variant* %29, %variant** %28, align 8
  %30 = bitcast %"variant[]"* %vararg21 to { i8*, i64 }*
  %31 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %30, i32 0, i32 0
  %lo23 = load i8*, i8** %31, align 8
  %32 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %30, i32 0, i32 1
  %hi24 = load i64, i64* %32, align 8
  %33 = call i64 @std_io_printfln(i64* %retparam17, i8* %lo19, i64 %hi20, i8* %lo23, i64 %hi24)
  %not_err25 = icmp eq i64 %33, 0
  br i1 %not_err25, label %after_check26, label %voiderr27

after_check26:                                    ; preds = %if.then16
  br label %voiderr27

voiderr27:                                        ; preds = %after_check26, %if.then16
  br label %if.exit28

if.exit28:                                        ; preds = %voiderr27, %end_block14
  store %"char[]" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i64 9 }, %"char[]"* %taddr30, align 8
  %34 = bitcast %"char[]"* %taddr30 to { i8*, i64 }*
  %35 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %34, i32 0, i32 0
  %lo31 = load i8*, i8** %35, align 8
  %36 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %34, i32 0, i32 1
  %hi32 = load i64, i64* %36, align 8
  %37 = load i64, i64* %a.f, align 8
  %not_err35 = icmp eq i64 %37, 0
  br i1 %not_err35, label %after_check36, label %voiderr41

after_check36:                                    ; preds = %if.exit28
  %38 = bitcast i32* %a to i8*
  %39 = insertvalue %variant undef, i8* %38, 0
  %40 = insertvalue %variant %39, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %41 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots34, i64 0, i64 0
  store %variant %40, %variant* %41, align 16
  %42 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg33, i32 0, i32 1
  store i64 1, i64* %42, align 8
  %43 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg33, i32 0, i32 0
  %44 = bitcast [1 x %variant]* %varargslots34 to %variant*
  store %variant* %44, %variant** %43, align 8
  %45 = bitcast %"variant[]"* %vararg33 to { i8*, i64 }*
  %46 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %45, i32 0, i32 0
  %lo37 = load i8*, i8** %46, align 8
  %47 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %45, i32 0, i32 1
  %hi38 = load i64, i64* %47, align 8
  %48 = call i64 @std_io_printfln(i64* %retparam29, i8* %lo31, i64 %hi32, i8* %lo37, i64 %hi38)
  %not_err39 = icmp eq i64 %48, 0
  br i1 %not_err39, label %after_check40, label %voiderr41

after_check40:                                    ; preds = %after_check36
  br label %voiderr41

voiderr41:                                        ; preds = %after_check40, %after_check36, %if.exit28
  store %"char[]" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.11, i32 0, i32 0), i64 9 }, %"char[]"* %taddr43, align 8
  %49 = bitcast %"char[]"* %taddr43 to { i8*, i64 }*
  %50 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %49, i32 0, i32 0
  %lo44 = load i8*, i8** %50, align 8
  %51 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %49, i32 0, i32 1
  %hi45 = load i64, i64* %51, align 8
  %52 = load i64, i64* %b.f, align 8
  %not_err48 = icmp eq i64 %52, 0
  br i1 %not_err48, label %after_check49, label %voiderr54

after_check49:                                    ; preds = %voiderr41
  %53 = bitcast i32* %b to i8*
  %54 = insertvalue %variant undef, i8* %53, 0
  %55 = insertvalue %variant %54, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %56 = getelementptr inbounds [1 x %variant], [1 x %variant]* %varargslots47, i64 0, i64 0
  store %variant %55, %variant* %56, align 16
  %57 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg46, i32 0, i32 1
  store i64 1, i64* %57, align 8
  %58 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg46, i32 0, i32 0
  %59 = bitcast [1 x %variant]* %varargslots47 to %variant*
  store %variant* %59, %variant** %58, align 8
  %60 = bitcast %"variant[]"* %vararg46 to { i8*, i64 }*
  %61 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %60, i32 0, i32 0
  %lo50 = load i8*, i8** %61, align 8
  %62 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %60, i32 0, i32 1
  %hi51 = load i64, i64* %62, align 8
  %63 = call i64 @std_io_printfln(i64* %retparam42, i8* %lo44, i64 %hi45, i8* %lo50, i64 %hi51)
  %not_err52 = icmp eq i64 %63, 0
  br i1 %not_err52, label %after_check53, label %voiderr54

after_check53:                                    ; preds = %after_check49
  br label %voiderr54

voiderr54:                                        ; preds = %after_check53, %after_check49, %voiderr41
  ret void
}

